---
title: "Factor Analysis"
author: "Hannah Andrews"
date: "4/30/2021"
output:
  pdf_document: default
  html_document: default
---

Sample: There are 6157 complete cases on CAM variables at Wave 1. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(foreign)
library(expss)
library(Hmisc)
library(dplyr)
library(summarytools)
library(magrittr)
library(tidyverse)
library(mosaic)
library(lattice)
library(ggplot2)
library(scales)
library(ggthemes)
library(polycor)
library(psych)
library(REdaS)
library(haven)
library(labelled)
library(mice)
library(GPArotation)
library(foreach)
library(doParallel)
library(questionr)
library(gridExtra)
library(DAKS)
library(fdth)
library(lavaan)
library(validateR)
library(corrplot)
library(knitr)
```



```{r, echo = FALSE, results = 'hide'}
# Read in MIDUS1 data and subset to complete cases on CAMs
# Read in stata file for MIDUS 1
path <- ("C:/Users/hanna/Documents/git/AHL/Stata/data-cleaning/MIDUS1.dta")
M1 <- read_dta(path)
acamsList <- c("acam1", "acam2", "acam3", "acam4", "acam5", "acam6", "acam7", 
               "acam8", "acam9", "acam10", "acam11", "acam12", "acam13", "acam14", "acam15")

acams <- M1[acamsList] # Subset MIDUS1 - only include CAMs.

# Remove attributes from acams data - created in Stata (labels and data notes). They're (were) producing an error with bart_spher.
acams <- remove_attributes(acams, "label")
acams <- remove_attributes(acams, "notes")

str(acams)

# Create column that is the sum of CAMs used 
totalCams <- rowSums(acams[,1:15])

acams[sapply(acams, is.numeric)] <- lapply(acams[sapply(acams, is.numeric)], as.factor) # convert all columns to factors

str(acams) 
head(acams)

# Rename columns 
acams <- dplyr::rename(acams, 
                          aAcupuncture = acam1, 
                          aBiofeedback = acam2,
                          aChiropractic = acam3,
                          aEnergyHeal = acam4,
                          aExerciseMove = acam5,
                          aHerbal = acam6,
                          aVitamins = acam7,
                          aHomeopathy = acam8,
                          aHypnosis = acam9,
                          aImageryTech = acam10,
                          aMassage = acam11,
                          aPrayer = acam12,
                          aRelaxMeditate = acam13,
                          aSpecialDiet = acam14,
                          aSpiritHeal = acam15)
head(acams)
# Keep only complete cases
acams=acams[complete.cases(acams),]
str(acams)
```

# CAM Descriptives 
## Frequencies and percentages on each variable 
```{r, echo = FALSE}
#apply(acams[, 1:15], 2 , questionr::freq)
freq_dframer <- function(data){
   quest_out   <- apply(data, 2, questionr::freq)
      templist <- list()
       for (i in 1:length(names(quest_out))) {
       temp <- data.frame(Item = rep(names(quest_out[i]), nrow(quest_out[[i]])),
                      Category = row.names(quest_out[[i]]),
                      quest_out[[i]])
       templist[[i]] <- temp
  }
      freqs <- dplyr::bind_rows(templist) 
      row.names(freqs) <- NULL
      names(freqs)[3:5] <- c("Frequency", "Percent", "Pcnt_of_nonMissing") 
      freqs$Item <- factor(freqs$Item, levels = unique(freqs$Item))
   freqs
}
freqout <- freq_dframer(acams)
freqout
```
## Visualization of frequencies
```{r, echo = FALSE}
# Relative frequencies 
ggplot(freqout, aes(x = Category, y = Frequency)) +
  geom_col() +
  facet_wrap(. ~ Item, nrow = 5 )
```
## Number of CAM treatments used in the past 12 months 
```{r, echo = FALSE}

# Convert column to a factor 
totalCams <- as.factor(totalCams)

# Relative frequencies 
prop.table(table(totalCams))

# Counts and percentages, relative and cumulative 
tb <- fdt_cat(totalCams)
tb

# create a histogram of total CAMs used 
# hist(as.numeric(totalCams))
```

# Analayses including all 15 CAMs 
## Correlation matrix 
Create and plot the tetrachoric correlation matrix for all CAMs. 
```{r, echo = FALSE}
# Create correlation matrix 
het.mat <- hetcor(acams)$cor
cor.plot(het.mat, numbers=T, upper=FALSE, main = "Tetrachoric Correlations", show.legend = TRUE, xlas = 2)
```

Check that items are not perfectly correlated with each other. 
```{r, echo=FALSE}
# EFA following https://www.youtube.com/watch?v=C5RJvMaHJNo&ab_channel=StatisticsofDOOM
# Channel: Statistics of DOOM by Lecturer: Dr. Erin M. Buchanan

# Screen data 
# nrow(acams)
# n = 5326

# Check min and max scores by running summary 
# summary(acams)

# Additivity - make sure nothing is correlated at 1. 
# don't want any 1s on the off diagonal.
symnum(het.mat)
```
## Test for correlation adequacy 
I will test for correlation adequacy using Bartlett's Sphericity test. This test tests the hypothesis that correlations between variables are greater than would be expected by chance. The null hypothesis states that all off diagonal are 0. If the null hypothesis is rejected there is correlation adequacy. 
```{r, echo = FALSE}
# Correlation adequacy Bartlett's test
cortest.bartlett(het.mat, n = nrow(acams))
```
I reject the null hypothesis. The CAM items are adequately correlated. 

## Test for sampling adequacy 
I will test for sampling adequacy using the Kaiser-Meyer-Olkin (KMO) test.MSA refers to the overall measure of sampling adequacy. MSAi refer to the measure of sampling adequacy for each item. MSA is a measure of the proportion of variance among variables that might be common variance. The lower the proportion of variance that is common the more suited the data are for factor analysis.  

MSA cutoffs: >.9 marvelous, .8s meritorious, .7s middling, .6s mediocre, .5s miserable, less than .5 is unacceptable.
```{r, echo=FALSE}
KMO(het.mat)
```
Items that may be a concern with regard to sampling adequacy: prayer or other spiritual practices, relaxation or meditation, and spiritual healing. Overall MSA indicates sampling adequacy. 

## Determining the number of factors
First, I will run a parallel analysis. From RDocumentation: "``Parallel" analyis is a technique that compares the scree of factors of the observed data with that of a random data matrix of the same size as the original."  
```{r, echo = FALSE, message=FALSE, results='hide'}
# Convert acams to numerics for parallel analysis
acams[] <- lapply(acams, function(x) as.numeric(as.character(x)))
str(acams)
#acams2 <- acams + 1
#str(acams2)
```
Parallel analysis completed using maximum likelihood factoring method. 
```{r, echo = FALSE, message = FALSE}
#nofactors <- fa.parallel(acams, fm = "ml", fa = "fa", main = "Parallel Analysis Scree Plots", cor = "tet")
#nofactors
# Ran with both the acams data and the tetrachoric correlation matrix obtained from hetcor to be sure the analysis is the same. Eigenvalues are the same in both parallel analyses. 
nofactors <- fa.parallel(het.mat, n.obs = 6157, fm = "ml", fa = "fa", main = "Parallel Analysis Scree Plots- hetmat")
```
I received many warning messages stating "A cell entry of 0 was replaced with correct =  0.5.  Check your data!" This has to do with continuity when computing a tetrachoric correlation matrix. I added 1 to all values in the dataframe to check that the issue was not the 0/1 values. The results were the same. 

From Statistics of DOOM notes: 
i.	The dark line is set at one, which is part of the Kaiser criterion. This method is an older rule of thumb that is not well supported anymore.  You would look at the number of eigenvalues that are greater than 1 (or .70 in new literature).  This rule tends to overestimate the number of factors/components needed.
ii.	The red dotted line is the random data set used to test this analysis. Your data is randomly reordered to see how many factors are better than chance. 
iii.	The blue line and triangles are your eigenvalues from the real dataset. 
iv.	You want to look at where the blue and red lines cross. 

The parallel analysis suggests 6 factors. This is where the lines cross. Looking at the scree plot, none of the drop offs appear to be very large. Seems like there are maybe 2 factors. 

Note: Scree plots are a visual depiction of the eigenvalues. Look for the large drop off to figure out how many factors to use.

## Kaiser Criterion 
```{r}
# older kaiser criterion, number of eigenvalues greater than 1 
sum(nofactors$fa.values > 1.0)
# new kaiser criterion, number of eigenvalues greater than 0.7
sum(nofactors$fa.values > .7)
```
New kaiser criterion rule (eigenvalues greater than 0.7) suggests 2 factors. 

After readings Ayers and Kronenfeld (2010), I will test the old CAM domains posted by the National Center for Complementary and Alternative Medicine (NCCAM), now the National Center for Complementary and Integrative Medicine (NCCIM). Then I will test the domains found by Ayers and Kronenfeld (2010). Finally, I will test the NCCIM's current CAM domains before performing exploratory factor analysis on the MIDUS data. 


## Fit Statistics: All models 
```{r, echo = FALSE, results='hide'}
# Create empty data frame to be filled with fit statistics 
acams15_fit_table_efa <- data.frame(Model=0, CFI=0, TLI=0, BIC=0, RMSR=0, RMSEA=0, Factors=0, FactorMethod=0, Rotation=0)  
# Create counter to be used in the loop to input statistics into successive rows
counter <- 1
# Write nested loops to run factor models on 1 through 6 factor solutions using all factoring methods and rotations and input model results into the data frame created above 
acams15_efa_fit <- foreach (i=1:6) %:%
  foreach(j=c("ml", "minres", "pa")) %:%
    foreach (k=c("varimax", "promax", "oblimin", "cluster")) %do% {
      model_i_j_k<- fa(r = het.mat, nfactors = i, n.obs=nrow(acams), rotate = k, max.iter = 100, fm = j)
      acams15_fit_table_efa [counter,"Model"] <- paste0(model_i_j_k$factors, model_i_j_k$fm, model_i_j_k$rotation)
      acams15_fit_table_efa [counter,"CFI"] <- 1 - ((model_i_j_k$STATISTIC-model_i_j_k$dof)/(model_i_j_k$null.chisq-model_i_j_k$null.dof))
      acams15_fit_table_efa [counter,"TLI"] <- model_i_j_k$TLI
      acams15_fit_table_efa [counter,"BIC"] <- model_i_j_k$BIC
      acams15_fit_table_efa [counter,"RMSR"] <- model_i_j_k$rms
      acams15_fit_table_efa [counter,"RMSEA"] <- model_i_j_k$RMSEA[1]
      acams15_fit_table_efa [counter, "Factors"] <- model_i_j_k$factors
      acams15_fit_table_efa [counter, "FactorMethod"] <- model_i_j_k$fm
      acams15_fit_table_efa [counter, "Rotation"] <- model_i_j_k$rotation
      return(acams15_fit_table_efa)
      counter <- counter + 1 
    }

# Convert the nested lists created by the nested loops above to a data frame. 
# 6 columns 72 rows (72 models)
acams15_df_unstacked <- unstack(data.frame(d<-unlist(acams15_efa_fit),names(d)))
acams15_df_unstacked

# Turn "Model" column into row names
acams15_df_rownames <- data.frame(acams15_df_unstacked[,-5],
                                  row.names=acams15_df_unstacked[,5])
acams15_df_rownames

# Reorder columns
col_order <- c("Factors", "FactorMethod", "Rotation", "BIC", "TLI", "CFI", "RMSR", "RMSEA")
acams15_df_rownames2 <- acams15_df_rownames[, col_order]
acams15_df_rownames2

str(acams15_df_rownames2)

# All columns are character vectors.
# Convert appropriate columns to numeric.
cols.num <- c("Factors", "BIC", "TLI", "CFI", "RMSR", "RMSEA")
acams15_df_rownames2[cols.num] <- sapply(acams15_df_rownames2[cols.num],as.numeric)
sapply(acams15_df_rownames2, class)

# Round numeric values to four decimal places
acams15_df <- modify_if(acams15_df_rownames2, ~is.numeric(.), ~round(., 4))
```
```{r, echo = FALSE}
kable(acams15_df, caption = "Fit Statistics for 1-6 Factor Models")
```
```{r, echo = FALSE}
# Maximum likelihood models tend to perform better, subset to just those. 
acams15_ml_models <- filter(acams15_df, FactorMethod == "ml")
view(acams15_ml_models)
```

## Factor loadings: All Models
```{r, echo = FALSE}
foreach (i=1:6) %:%
  foreach(j=c("ml", "minres", "pa")) %:%
  foreach (k=c("varimax", "promax", "oblimin", "cluster")) %do% {
    model_i_j_k<- fa(r = het.mat, nfactors = i, n.obs=nrow(acams), rotate = k, max.iter = 100, fm = j)
    model_i_j_k.diagram <- fa.diagram(model_i_j_k, cut = .299, sort = TRUE, main = paste0(model_i_j_k$factors, model_i_j_k$fm, model_i_j_k$rotation))
    return(model_i_j_k.diagram)
  }
```

# Combining Prayer and Spiritual Healing 
```{r, echo = FALSE, results = 'hide'}
# This code chunk combines prayer and spiritual healing and drops aPrayer and aSpiritHeal 
acams <- acams %>% 
  rowwise() %>% 
  mutate(
    aPraySpirit = case_when(
      aPrayer == 0 & aSpiritHeal == 0 ~ 0,
      aPrayer == 1 & aSpiritHeal == 1 ~ 1, 
      aPrayer == 1 & aSpiritHeal == 0 ~ 1, 
      aPrayer == 0 & aSpiritHeal == 1 ~ 1)
    ) %>% 
  mutate_if(is.numeric, as.factor)
check.vars <- c("aPrayer", "aSpiritHeal", "aPraySpirit")
view(acams[check.vars])

# Check that code ran correctly with crosstabs 
# Prayer and Spiritual Healing
table.pray.spirit
# 4304 cases report no on both prayer and spiritual healing. aPraySpirit should have 4304 0/nos and 1853 1/yeses. 
table(acams$aPraySpirit)
# Correct.
# Check that no cases that responded yes on prayer are coded as 0 on the new variable.
acams %>%
  tabyl(aPrayer, aPraySpirit)
# Correct. 
# Chcek that no cases that responded yes on spiritual healing are coded as 0 on the new variable.
acams %>%  
  tabyl(aSpiritHeal, aPraySpirit)
# Correct. 
# Check that aPraySpirit is a factor.
class(acams$aPraySpirit)

# Drop prayer and spiritual healing columns 
acams <- subset(acams, select = -c(aPrayer, aSpiritHeal))
str(acams)
```

```{r, echo = FALSE, fig.cap = "Tetrachoric Correlation Matrix"}
# Create correlation matrix 
het.mat <- hetcor(acams)$cor
# Rename columns for correlation matrix visualization 
colnames(het.mat) <- c("Acupuncture", "Biofeedback", "Chiropractic", "Energy Healing", 
                  "Exercise", "Herbal Therapy", "Vitamins", 
                  "Homeopathy", "Hypnosis", "Imagery", "Massage", 
                  "Relaxiation", "Special Diet", "Prayer/Spiritual Healing")
rownames(het.mat) <- c("Acupuncture", "Biofeedback", "Chiropractic", "Energy Healing", 
                  "Exercise", "Herbal Therapy", "Vitamins", 
                  "Homeopathy", "Hypnosis", "Imagery Techniques", "Massage",
                  "Relaxiation Techniques", "Special Diet", "Prayer/Spiritual Healing")
```
```{r, echo = FALSE, fig.cap = "Tetrachoric Correlations for CAM items"}
# Visualize correlation matrix 
#corrplot.mixed(het.mat, tl.pos = "lt", tl.col = "black", tl.cex = .8, tl.srt=45, number.cex = .5, lower.col = "black", order = "hclust")
col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
corrplot(het.mat, method="color", number.cex = .5, order="hclust", 
         addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45 #Text label color and rotation
         )
```

# START HERE 

# Exclude prayer and spiritual healing 
```{r, echo = FALSE, results = 'hide'}
# Remove aPrayer and aSpiritHeal from acams
acams13 <- subset(acams, select = -c(aPrayer, aSpiritHeal))
str(acams13)
# convert all columns to factors. This is important for the tetrachoric correlations. They are much smaller when run as numeric. 
# Checked against tetrachoric matrix produced by Stata; they are the same when hetcor is run on factors in R.
# Will have to convert back to numeric for parallel analysis. 
acams13[sapply(acams13, is.numeric)] <- lapply(acams13[sapply(acams13, is.numeric)], as.factor)
str(acams13)
# Create correlation matrix 
het.mat13 <- hetcor(acams13)$cor
```
## Tetrachoric correlations (excluding prayer and spiritual healing)
```{r, echo = FALSE, result = 'hide'}
cor.plot(het.mat13, numbers=T, upper=FALSE, main = "Tetrachoric Correlations excluding prayer and spiritual healing ", show.legend = TRUE, xlas = 2)
```
```{r, echo = FALSE}
corrplot(het.mat13)
corrplot(het.mat13, is.corr=FALSE, method="square", order="hclust")
```

## Test for correlation adequacy 

Bartlett's test for sphericity. 
```{r, echo = FALSE}
# Correlation adequacy Bartlett's test
cortest.bartlett(het.mat13, n = nrow(acams))
```
Items are adequately correlated. 

## Test for sampling adequacy 

MSA cutoffs: >.9 marvelous, .8s meritorious, .7s middling, .6s mediocre, .5s miserable, less than .5 is unacceptable.
```{r, echo=FALSE}
KMO(het.mat13)$MSA
sort(KMO(het.mat13)$MSAi)
```

## Determining number of factors 

### Parallel Analysis 
```{r, echo = FALSE, message=FALSE, results='hide'}
# Convert acams13 to numeric for parallel analysis
acams13[] <- lapply(acams13, function(x) as.numeric(as.character(x)))
str(acams13)
```
```{r, echo = FALSE, message = FALSE}
parallel_ML13 <- fa.parallel(acams13, fm = "ml", fa = "fa", main = "Parallel Analysis Scree Plots excluding prayer and spiritual healing, ML", cor = "tet")
```
The parallel analysis suggests 5 factors. There is a drop off on the scree plot after 4. 

### Kaiser Criterion 
Older kaiser criterion suggests number of factors is equal to the number of eigenvalues greater than 1. The new kaiser criterion suggests numbers of factors is equal to the number of eigenvalues greater than 0.7
```{r, echo = FALSE}
e <- eigen(het.mat13)
round(e$values, digits = 4)
```
Suggests 4 or 5 factors. 

### Reliability among ACAMs excluding prayer and spiritual healing 
```{r, echo = FALSE}
ML1 <- c(1:13)
exprayheal1_ML1 <- psych::alpha(acams13[, ML1])
exprayheal1_ML1$total
```
Removing prayer and spiritual healing does not improve the reliability at all. Raw alpha is almost exactly the same, 0.68. Lowers reliability slightly (from 0.695). 

##Fit Statistics: All models
```{r, echo = FALSE, results='hide'}
test <- fa(r = het.mat13, nfactors = 1, n.obs=nrow(acams), rotate = "oblimin", max.iter = 1000, fm = "ml")
test


# Create empty data frame to be filled with fit statistics 
acams13_fit_table_efa <- data.frame(Model=0, CFI=0, TLI=0, BIC=0, RMSR=0, RMSEA=0, Factors=0, FactorMethod=0, Rotation=0)  
# Create counter to be used in the loop to input statistics into successive rows
counter <- 1
# Write nested loops to run factor models on 1 through 6 factor solutions using all factoring methods and rotations and input model results into the data frame created above 
acams13_efa_fit <- foreach (i=1:5) %:%
  foreach(j=c("ml", "minres")) %:%
    foreach (k=c("varimax", "promax", "oblimin", "cluster")) %do% {
      model_i_j_k<- fa(r = het.mat13, nfactors = i, n.obs=nrow(acams), rotate = k, max.iter = 1000, fm = j)
      acams13_fit_table_efa [counter,"Model"] <- paste0(model_i_j_k$factors, model_i_j_k$fm, model_i_j_k$rotation)
      acams13_fit_table_efa [counter,"CFI"] <- 1 - ((model_i_j_k$STATISTIC-model_i_j_k$dof)/(model_i_j_k$null.chisq-model_i_j_k$null.dof))
      acams13_fit_table_efa [counter,"TLI"] <- model_i_j_k$TLI
      acams13_fit_table_efa [counter,"BIC"] <- model_i_j_k$BIC
      acams13_fit_table_efa [counter,"RMSR"] <- model_i_j_k$rms
      acams13_fit_table_efa [counter,"RMSEA"] <- model_i_j_k$RMSEA[1]
      acams13_fit_table_efa [counter, "Factors"] <- model_i_j_k$factors
      acams13_fit_table_efa [counter, "FactorMethod"] <- model_i_j_k$fm
      acams13_fit_table_efa [counter, "Rotation"] <- model_i_j_k$rotation
      return(acams13_fit_table_efa)
      counter <- counter + 1 
    }

# Convert the nested lists created by the nested loops above to a data frame. 
# 6 columns 72 rows (72 models)
acams13_df_unstacked <- unstack(data.frame(d<-unlist(acams13_efa_fit),names(d)))
acams13_df_unstacked

# Turn "Model" column into row names
acams13_df_rownames <- data.frame(acams13_df_unstacked[,-5],
                                  row.names=acams13_df_unstacked[,5])
acams13_df_rownames

# Reorder columns
col_order <- c("Factors", "FactorMethod", "Rotation", "BIC", "TLI", "CFI", "RMSR", "RMSEA")
acams13_df_rownames2 <- acams13_df_rownames[, col_order]
acams13_df_rownames2

str(acams13_df_rownames2)

# All columns are character vectors.
# Convert appropriate columns to numeric.
cols.num <- c("Factors", "BIC", "TLI", "CFI", "RMSR", "RMSEA")
acams13_df_rownames2[cols.num] <- sapply(acams13_df_rownames2[cols.num],as.numeric)
sapply(acams13_df_rownames2, class)

# Round numeric values to four decimal places
acams13_df <- modify_if(acams13_df_rownames2, ~is.numeric(.), ~round(., 4))
```


```{r, echo = FALSE, results = 'hide'}
# 06/24/21 
# When running the nested loop in the previous code chunk, I recieved the following error. Removing "pa" from the loop (principal axis factoring method) took care of the error and the loop ran smoothly. 

# NaNs producedimaginary eigen value condition encountered in fa
#  Try again with SMC=FALSE 
#  exiting faNaNs producedimaginary eigen value condition encountered in fa
#  Try again with SMC=FALSE 
#  exiting faNaNs producedimaginary eigen value condition encountered in fa
#  Try again with SMC=FALSE 
#  exiting faError in if (s < eps) break : missing value where TRUE/FALSE needed
# The requested transformaton failed, Promax was used instead as an oblique transformationNaNs producedimaginary eigen value condition encountered in fa
#  Try again with SMC=FALSE 
#  exiting faError in { : task 1 failed - "infinite or missing values in 'x'"
```

```{r, echo = FALSE}
kable(acams13_df, caption = "Fit Statistics for 1-5 Factor Models Excluding Prayer and Spiritual Healing")
```
## Factor loadings: 3 through 5 factor models
```{r, echo = FALSE}
foreach (i=3:5) %:%
  foreach(j=c("ml", "minres")) %:%
  foreach (k=c("varimax", "promax", "oblimin", "cluster")) %do% {
    model_i_j_k<- fa(r = het.mat13, nfactors = i, n.obs=nrow(acams), rotate = k, max.iter = 100, fm = j)
    model_i_j_k.diagram <- fa.diagram(model_i_j_k, cut = .299, sort = TRUE, main = paste0(model_i_j_k$factors, model_i_j_k$fm, model_i_j_k$rotation))
    return(model_i_j_k.diagram)
  }
```

# Exclude prayer, spiritual healing, and energy healing 
## Tetrachoric correlation matrix
```{r, echo = FALSE, results= 'hide'}
acams12 <- subset(acams, select = -c(aPrayer, aSpiritHeal, aEnergyHeal))
acams12
# Converts all columns to factor 
acams12[sapply(acams12, is.numeric)] <- lapply(acams12[sapply(acams12, is.numeric)], as.factor) # convert all columns to factors
# Create correlation matrix 
het.mat12 <- hetcor(acams12)$cor
```
```{r, echo = FALSE}
# cor.plot(het.mat12, numbers=T, upper=FALSE, main = "Tetrachoric Correlations excluding pray, spirit, energy", show.legend = TRUE, xlas = 2)
corrplot(het.mat12)
corrplot(het.mat12, is.corr=FALSE, method="square", order="hclust")
```
## Bartlett's Test of Spherecity
I will test for correlation adequacy using Bartlett's Sphericity test. This test tests the hypothesis that correlations between variables are greater than would be expected by chance. The null hypothesis states that all off diagonal are 0. If the null hypothesis is rejected there is correlation adequacy. 
```{r, echo = FALSE}
# Correlation adequacy Bartlett's test
cortest.bartlett(het.mat12, n = nrow(acams))
```
## KMO Test for sampling adequacy 
MSA cutoffs: >.9 marvelous, .8s meritorious, .7s middling, .6s mediocre, .5s miserable, less than .5 is unacceptable.
```{r, echo=FALSE}
# Total MSA
KMO(het.mat12)$MSA

## Now for the individual items, sorted from low to high:
sort(KMO(het.mat12)$MSAi)
```
Great.

## Parallel Analysis 
First, I will run a parallel analysis. From RDocumentation: "``Parallel" analyis is a technique that compares the scree of factors of the observed data with that of a random data matrix of the same size as the original."  
```{r, echo = FALSE, message = FALSE}
#nofactors <- fa.parallel(acams, fm = "ml", fa = "fa", main = "Parallel Analysis Scree Plots", cor = "tet")
#nofactors
# Ran with both the acams data and the tetrachoric correlation matrix obtained from hetcor to be sure the analysis is the same. Eigenvalues are the same in both parallel analyses. 
acams12_parallelMl <- fa.parallel(het.mat12, n.obs = 6157, fm = "ml", fa = "fa", main = "Parallel Analysis Scree Plots- hetmat12, maximum likelihood")
```
The parallel analysis suggests 5 factors. This is where the lines cross. Looking at the scree plot, there is a drop at 4 factors. 

### Kaiser Criterion 
Older kaiser criterion suggests number of factors is equal to the number of eigenvalues greater than 1. The new kaiser criterion suggests numbers of factors is equal to the number of eigenvalues greater than 0.7
```{r, echo = FALSE}
e <- eigen(het.mat12)
round(e$values, digits = 4)
```
Indicates 4 or 5 factors. 

##Fit Statistics: All models
```{r, echo = FALSE, results='hide'}
# Create empty data frame to be filled with fit statistics 
acams12_fit_table_efa <- data.frame(Model=0, CFI=0, TLI=0, BIC=0, RMSR=0, RMSEA=0, Factors=0, FactorMethod=0, Rotation=0)  
# Create counter to be used in the loop to input statistics into successive rows
counter <- 1
# Write nested loops to run factor models on 1 through 6 factor solutions using all factoring methods and rotations and input model results into the data frame created above 
acams12_efa_fit <- foreach (i=2:5) %:%
  foreach(j=c("ml", "minres",  "pa")) %:%
    foreach (k=c("varimax", "promax", "oblimin", "cluster")) %do% {
      model_i_j_k<- fa(r = het.mat12, nfactors = i, n.obs=nrow(acams), rotate = k, max.iter = 1000, fm = j)
      acams12_fit_table_efa [counter,"Model"] <- paste0(model_i_j_k$factors, model_i_j_k$fm, model_i_j_k$rotation)
      acams12_fit_table_efa [counter,"CFI"] <- 1 - ((model_i_j_k$STATISTIC-model_i_j_k$dof)/(model_i_j_k$null.chisq-model_i_j_k$null.dof))
      acams12_fit_table_efa [counter,"TLI"] <- model_i_j_k$TLI
      acams12_fit_table_efa [counter,"BIC"] <- model_i_j_k$BIC
      acams12_fit_table_efa [counter,"RMSR"] <- model_i_j_k$rms
      acams12_fit_table_efa [counter,"RMSEA"] <- model_i_j_k$RMSEA[1]
      acams12_fit_table_efa [counter, "Factors"] <- model_i_j_k$factors
      acams12_fit_table_efa [counter, "FactorMethod"] <- model_i_j_k$fm
      acams12_fit_table_efa [counter, "Rotation"] <- model_i_j_k$rotation
      return(acams12_fit_table_efa)
      counter <- counter + 1 
    }

# Convert the nested lists created by the nested loops above to a data frame. 
# 6 columns 72 rows (72 models)
acams12_df_unstacked <- unstack(data.frame(d<-unlist(acams12_efa_fit),names(d)))
acams12_df_unstacked

# Turn "Model" column into row names
acams12_df_rownames <- data.frame(acams12_df_unstacked[,-5],
                                  row.names=acams12_df_unstacked[,5])
acams12_df_rownames

# Reorder columns
col_order <- c("Factors", "FactorMethod", "Rotation", "BIC", "TLI", "CFI", "RMSR", "RMSEA")
acams12_df_rownames2 <- acams12_df_rownames[, col_order]
acams12_df_rownames2

str(acams12_df_rownames2)

# All columns are character vectors.
# Convert appropriate columns to numeric.
cols.num <- c("Factors", "BIC", "TLI", "CFI", "RMSR", "RMSEA")
acams12_df_rownames2[cols.num] <- sapply(acams12_df_rownames2[cols.num],as.numeric)
sapply(acams12_df_rownames2, class)

# Round numeric values to four decimal places
acams12_df <- modify_if(acams12_df_rownames2, ~is.numeric(.), ~round(., 4))
```
```{r, echo = FALSE}
kable(acams12_df, caption = "Fit Statistics for 1-5 Factor Models Excluding Prayer, Spiritual Healing, and Energy Healing")
```
## Factor loadings: Three through 5 factor models 
```{r, echo = FALSE}
foreach (i=3:5) %:%
  foreach(j=c("ml", "minres", "pa")) %:%
  foreach (k=c("varimax", "promax", "oblimin", "cluster")) %do% {
    model_i_j_k<- fa(r = het.mat12, nfactors = i, n.obs=nrow(acams), rotate = k, max.iter = 100, fm = j)
    model_i_j_k.diagram <- fa.diagram(model_i_j_k, cut = .299, sort = TRUE, main = paste0(model_i_j_k$factors, model_i_j_k$fm, model_i_j_k$rotation))
    return(model_i_j_k.diagram)
  }
```

# Excluding prayer, spiritual healing, biofeedback, and hypnosis. 
```{r, echo = FALSE, results = 'hide'}
# Remove aPrayer and aSpiritHeal from acams
acams11 <- subset(acams, select = -c(aPrayer, aSpiritHeal, aBiofeedback, aHypnosis))
acams11
# Create correlation matrix 
het.mat11 <- hetcor(acams11)$cor
```
## Tetrachoric correlations
```{r, echo = FALSE}
corrplot(het.mat11)
corrplot(het.mat11, is.corr=FALSE, method="square", order="hclust")
```
## Bartlett's Test of Spherecity
I will test for correlation adequacy using Bartlett's Sphericity test. This test tests the hypothesis that correlations between variables are greater than would be expected by chance. The null hypothesis states that all off diagonal are 0. If the null hypothesis is rejected there is correlation adequacy. 
```{r, echo = FALSE}
# Correlation adequacy Bartlett's test
cortest.bartlett(het.mat11, n = nrow(acams))
```
## KMO Test for sampling adequacy
MSA cutoffs: >.9 marvelous, .8s meritorious, .7s middling, .6s mediocre, .5s miserable, less than .5 is unacceptable.
```{r, echo=FALSE}
# Total MSA
KMO(het.mat11)$MSA
## Now for the individual items, sorted from low to high:
sort(KMO(het.mat11)$MSAi)
```

## Parallel Analysis
```{r, echo = FALSE}
acams11_parallel <- fa.parallel(het.mat11, n.obs = 6157, fm = "ml", fa = "fa", main = "Parallel Analysis Scree Plots- hetmat")
```
Suggests 4 factors. 

### Kaiser Criterion
```{r, echo = FALSE}

## Ron comment: Let's look at the eigenvalues, rounded to 4 decimal places:
e <- eigen(het.mat11)
round(e$values, digits = 4)
```
 Suggests 4 factors.
## Fit Statistics: All models 
```{r, echo = FALSE, results='hide'}
# Create empty data frame to be filled with fit statistics 
acams11_fit_table_efa <- data.frame(Model=0, CFI=0, TLI=0, BIC=0, RMSR=0, RMSEA=0, Factors=0, FactorMethod=0, Rotation=0)  
# Create counter to be used in the loop to input statistics into successive rows
counter <- 1
# Write nested loops to run factor models on 1 through 6 factor solutions using all factoring methods and rotations and input model results into the data frame created above 
acams11_efa_fit <- foreach (i=1:4) %:%
  foreach(j=c("ml", "minres")) %:%
    foreach (k=c("varimax", "promax", "oblimin", "cluster")) %do% {
      model_i_j_k<- fa(r = het.mat11, nfactors = i, n.obs=nrow(acams), rotate = k, max.iter = 1000, fm = j)
      acams11_fit_table_efa [counter,"Model"] <- paste0(model_i_j_k$factors, model_i_j_k$fm, model_i_j_k$rotation)
      acams11_fit_table_efa [counter,"CFI"] <- 1 - ((model_i_j_k$STATISTIC-model_i_j_k$dof)/(model_i_j_k$null.chisq-model_i_j_k$null.dof))
      acams11_fit_table_efa [counter,"TLI"] <- model_i_j_k$TLI
      acams11_fit_table_efa [counter,"BIC"] <- model_i_j_k$BIC
      acams11_fit_table_efa [counter,"RMSR"] <- model_i_j_k$rms
      acams11_fit_table_efa [counter,"RMSEA"] <- model_i_j_k$RMSEA[1]
      acams11_fit_table_efa [counter, "Factors"] <- model_i_j_k$factors
      acams11_fit_table_efa [counter, "FactorMethod"] <- model_i_j_k$fm
      acams11_fit_table_efa [counter, "Rotation"] <- model_i_j_k$rotation
      return(acams11_fit_table_efa)
      counter <- counter + 1 
    }

# Convert the nested lists created by the nested loops above to a data frame. 
# 6 columns 72 rows (72 models)
acams11_df_unstacked <- unstack(data.frame(d<-unlist(acams11_efa_fit),names(d)))
acams11_df_unstacked

# Turn "Model" column into row names
acams11_df_rownames <- data.frame(acams11_df_unstacked[,-5],
                                  row.names=acams11_df_unstacked[,5])
acams11_df_rownames

# Reorder columns
col_order <- c("Factors", "FactorMethod", "Rotation", "BIC", "TLI", "CFI", "RMSR", "RMSEA")
acams11_df_rownames2 <- acams11_df_rownames[, col_order]
acams11_df_rownames2

str(acams11_df_rownames2)

# All columns are character vectors.
# Convert appropriate columns to numeric.
cols.num <- c("Factors", "BIC", "TLI", "CFI", "RMSR", "RMSEA")
acams11_df_rownames2[cols.num] <- sapply(acams11_df_rownames2[cols.num],as.numeric)
sapply(acams11_df_rownames2, class)

# Round numeric values to four decimal places
acams11_df <- modify_if(acams11_df_rownames2, ~is.numeric(.), ~round(., 4))
```
```{r, echo = FALSE}
kable(acams11_df, caption = "Fit Statistics for 1-4 Factor Models Excluding Prayer, Spiritual Healing, Biofeedback, and Hypnosis")
```

## Factor loadings: 3 through 5 factor models 
```{r, echo = FALSE}
foreach (i=3:5) %:%
  foreach(j=c("ml", "minres")) %:%
  foreach (k=c("varimax", "promax", "oblimin", "cluster")) %do% {
    model_i_j_k<- fa(r = het.mat11, nfactors = i, n.obs=nrow(acams), rotate = k, max.iter = 100, fm = j)
    model_i_j_k.diagram <- fa.diagram(model_i_j_k, cut = .299, sort = TRUE, main = paste0(model_i_j_k$factors, model_i_j_k$fm, model_i_j_k$rotation))
    return(model_i_j_k.diagram)
  }
```

```{r, echo = FALSE, results = 'hide'}
# From meeting with Terrence, 06/25/21

# Excluding prayer, spiritual healing, chiro and special diet
acams.test <- subset(acams, select = -c(aPrayer, aSpiritHeal, aChiropractic, aSpecialDiet))
acams.test
# Create correlation matrix 
het.mat.test <- hetcor(acams.test)$cor
acams.test[] <- lapply(acams.test, function(x) as.numeric(as.character(x)))

# Run factor model
test2 <- fa(r = het.mat.test, nfactors = 1, n.obs = nrow(acams), rotate = "varimax", fm = "ml")
test2
kr20(acams.test)
acams[] <- lapply(acams, function(x) as.numeric(as.character(x)))
kr20(acams)

# Excluding prayer/spiritual, and all items with fewer than 100 yes cases
acams.test2 <- subset(acams, select = -c(aPrayer, aSpiritHeal, aAcupuncture, aBiofeedback, aEnergyHeal, aHypnosis))
acams.test2
# Create correlation matrix 
het.mat.test2 <- hetcor(acams.test2)$cor

test3 <- fa(r = het.mat.test2, nfactors = 1, n.obs = nrow(acams), rotate = "varimax", fm = "ml")
test3

test3.cfi <- 1 - ((test3$STATISTIC-test3$dof)/(test3$null.chisq-test3$null.dof))
test3.cfi

acams.test2[] <- lapply(acams.test2, function(x) as.numeric(as.character(x))) # convert to numeric 
kr20(acams.test2) 

test3$loadings

```
06/25/21 Conclusions from meeting with Terrence 
There does not appear to be an underlying latent factor motivating all of these behaviors. Why- fit statistics and low reliability even with all items included.

